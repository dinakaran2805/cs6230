//
// Generated by Bluespec Compiler, version 2022.01-10-g3a4741b2 (build 3a4741b2)
//
// On Sat Dec  9 01:41:06 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_send                       O     1 const
// receive                        O     8 reg
// RDY_receive                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// send_data_input                I    80 reg
// EN_send                        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module cfloat8_mul(CLK,
		   RST_N,

		   send_data_input,
		   EN_send,
		   RDY_send,

		   receive,
		   RDY_receive);
  input  CLK;
  input  RST_N;

  // action method send
  input  [79 : 0] send_data_input;
  input  EN_send;
  output RDY_send;

  // value method receive
  output [7 : 0] receive;
  output RDY_receive;

  // signals for module outputs
  wire [7 : 0] receive;
  wire RDY_receive, RDY_send;

  // register exp_op1
  reg [3 : 0] exp_op1;
  wire [3 : 0] exp_op1$D_IN;
  wire exp_op1$EN;

  // register exp_op2
  reg [3 : 0] exp_op2;
  wire [3 : 0] exp_op2$D_IN;
  wire exp_op2$EN;

  // register final_exp
  reg [3 : 0] final_exp;
  wire [3 : 0] final_exp$D_IN;
  wire final_exp$EN;

  // register final_man
  reg [7 : 0] final_man;
  wire [7 : 0] final_man$D_IN;
  wire final_man$EN;

  // register final_output
  reg [7 : 0] final_output;
  wire [7 : 0] final_output$D_IN;
  wire final_output$EN;

  // register final_sign
  reg final_sign;
  wire final_sign$D_IN, final_sign$EN;

  // register man_op1
  reg [2 : 0] man_op1;
  wire [2 : 0] man_op1$D_IN;
  wire man_op1$EN;

  // register man_op2
  reg [2 : 0] man_op2;
  wire [2 : 0] man_op2$D_IN;
  wire man_op2$EN;

  // register normalized_count
  reg [3 : 0] normalized_count;
  wire [3 : 0] normalized_count$D_IN;
  wire normalized_count$EN;

  // register normalized_man
  reg [5 : 0] normalized_man;
  wire [5 : 0] normalized_man$D_IN;
  wire normalized_man$EN;

  // register output_man
  reg [2 : 0] output_man;
  wire [2 : 0] output_man$D_IN;
  wire output_man$EN;

  // register rg_operands
  reg [79 : 0] rg_operands;
  wire [79 : 0] rg_operands$D_IN;
  wire rg_operands$EN;

  // register sign_op1
  reg sign_op1;
  wire sign_op1$D_IN, sign_op1$EN;

  // register sign_op2
  reg sign_op2;
  wire sign_op2$D_IN, sign_op2$EN;

  // register stage
  reg [2 : 0] stage;
  reg [2 : 0] stage$D_IN;
  wire stage$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_display_output,
       CAN_FIRE_RL_stage1,
       CAN_FIRE_RL_stage2,
       CAN_FIRE_RL_stage3,
       CAN_FIRE_RL_stage4,
       CAN_FIRE_RL_trial,
       CAN_FIRE_send,
       WILL_FIRE_RL_display_output,
       WILL_FIRE_RL_stage1,
       WILL_FIRE_RL_stage2,
       WILL_FIRE_RL_stage3,
       WILL_FIRE_RL_stage4,
       WILL_FIRE_RL_trial,
       WILL_FIRE_send;

  // inputs to muxes for submodule ports
  wire [2 : 0] MUX_stage$write_1__VAL_2;
  wire MUX_stage$write_1__SEL_3;

  // remaining internal signals
  wire [15 : 0] _0_CONCAT_NOT_exp_op1_4_EQ_0_3_4_CONCAT_man_op1_ETC___d33;
  wire [7 : 0] inter_mantissa1__h1297, inter_mantissa2__h1298;
  wire [3 : 0] x__h1329, x__h1336;
  wire hidden_bit_op1__h1229, hidden_bit_op2__h1230;

  // action method send
  assign RDY_send = 1'd1 ;
  assign CAN_FIRE_send = 1'd1 ;
  assign WILL_FIRE_send = EN_send ;

  // value method receive
  assign receive = final_output ;
  assign RDY_receive = 1'd1 ;

  // rule RL_trial
  assign CAN_FIRE_RL_trial = 1'd1 ;
  assign WILL_FIRE_RL_trial = 1'd1 ;

  // rule RL_stage1
  assign CAN_FIRE_RL_stage1 = stage == 3'd1 ;
  assign WILL_FIRE_RL_stage1 = CAN_FIRE_RL_stage1 ;

  // rule RL_stage2
  assign CAN_FIRE_RL_stage2 = stage == 3'd2 ;
  assign WILL_FIRE_RL_stage2 = CAN_FIRE_RL_stage2 ;

  // rule RL_stage3
  assign CAN_FIRE_RL_stage3 = stage == 3'd3 ;
  assign WILL_FIRE_RL_stage3 = CAN_FIRE_RL_stage3 ;

  // rule RL_stage4
  assign CAN_FIRE_RL_stage4 = stage == 3'd4 ;
  assign WILL_FIRE_RL_stage4 = CAN_FIRE_RL_stage4 ;

  // rule RL_display_output
  assign CAN_FIRE_RL_display_output = stage == 3'd5 ;
  assign WILL_FIRE_RL_display_output = CAN_FIRE_RL_display_output ;

  // inputs to muxes for submodule ports
  assign MUX_stage$write_1__SEL_3 = WILL_FIRE_RL_stage3 && final_man != 8'b0 ;
  assign MUX_stage$write_1__VAL_2 = stage + 3'd1 ;

  // register exp_op1
  assign exp_op1$D_IN = rg_operands[78:75] ;
  assign exp_op1$EN = CAN_FIRE_RL_stage2 ;

  // register exp_op2
  assign exp_op2$D_IN = rg_operands[70:67] ;
  assign exp_op2$EN = CAN_FIRE_RL_stage2 ;

  // register final_exp
  assign final_exp$D_IN = exp_op1 + exp_op2 ;
  assign final_exp$EN = CAN_FIRE_RL_stage2 ;

  // register final_man
  assign final_man$D_IN =
	     _0_CONCAT_NOT_exp_op1_4_EQ_0_3_4_CONCAT_man_op1_ETC___d33[7:0] ;
  assign final_man$EN = CAN_FIRE_RL_stage3 ;

  // register final_output
  assign final_output$D_IN = { final_sign, final_exp, output_man } ;
  assign final_output$EN = CAN_FIRE_RL_stage4 ;

  // register final_sign
  assign final_sign$D_IN = sign_op1 ^ sign_op2 ;
  assign final_sign$EN = CAN_FIRE_RL_stage1 ;

  // register man_op1
  assign man_op1$D_IN = rg_operands[74:72] ;
  assign man_op1$EN = CAN_FIRE_RL_stage3 ;

  // register man_op2
  assign man_op2$D_IN = rg_operands[66:64] ;
  assign man_op2$EN = CAN_FIRE_RL_stage3 ;

  // register normalized_count
  assign normalized_count$D_IN = 4'h0 ;
  assign normalized_count$EN = 1'b0 ;

  // register normalized_man
  assign normalized_man$D_IN = final_man[5:0] ;
  assign normalized_man$EN = WILL_FIRE_RL_stage4 && final_man[7:6] == 2'b01 ;

  // register output_man
  assign output_man$D_IN = 3'h0 ;
  assign output_man$EN = 1'b0 ;

  // register rg_operands
  assign rg_operands$D_IN = send_data_input ;
  assign rg_operands$EN = EN_send ;

  // register sign_op1
  assign sign_op1$D_IN = rg_operands[79] ;
  assign sign_op1$EN = CAN_FIRE_RL_stage1 ;

  // register sign_op2
  assign sign_op2$D_IN = rg_operands[71] ;
  assign sign_op2$EN = CAN_FIRE_RL_stage1 ;

  // register stage
  always@(EN_send or
	  WILL_FIRE_RL_stage4 or
	  MUX_stage$write_1__VAL_2 or
	  MUX_stage$write_1__SEL_3 or
	  WILL_FIRE_RL_stage2 or WILL_FIRE_RL_stage1)
  case (1'b1)
    EN_send: stage$D_IN = 3'd1;
    WILL_FIRE_RL_stage4: stage$D_IN = MUX_stage$write_1__VAL_2;
    MUX_stage$write_1__SEL_3: stage$D_IN = MUX_stage$write_1__VAL_2;
    WILL_FIRE_RL_stage2: stage$D_IN = MUX_stage$write_1__VAL_2;
    WILL_FIRE_RL_stage1: stage$D_IN = MUX_stage$write_1__VAL_2;
    default: stage$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign stage$EN =
	     WILL_FIRE_RL_stage3 && final_man != 8'b0 ||
	     WILL_FIRE_RL_stage4 ||
	     WILL_FIRE_RL_stage2 ||
	     WILL_FIRE_RL_stage1 ||
	     EN_send ;

  // remaining internal signals
  assign _0_CONCAT_NOT_exp_op1_4_EQ_0_3_4_CONCAT_man_op1_ETC___d33 =
	     inter_mantissa1__h1297 * inter_mantissa2__h1298 ;
  assign hidden_bit_op1__h1229 = exp_op1 != 4'd0 ;
  assign hidden_bit_op2__h1230 = exp_op2 != 4'd0 ;
  assign inter_mantissa1__h1297 = { 4'd0, x__h1329 } ;
  assign inter_mantissa2__h1298 = { 4'd0, x__h1336 } ;
  assign x__h1329 = { hidden_bit_op1__h1229, man_op1 } ;
  assign x__h1336 = { hidden_bit_op2__h1230, man_op2 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        exp_op1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	exp_op2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	final_exp <= `BSV_ASSIGNMENT_DELAY 4'd0;
	final_man <= `BSV_ASSIGNMENT_DELAY 8'd0;
	final_output <= `BSV_ASSIGNMENT_DELAY 8'd0;
	final_sign <= `BSV_ASSIGNMENT_DELAY 1'd0;
	man_op1 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	man_op2 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	normalized_count <= `BSV_ASSIGNMENT_DELAY 4'd0;
	normalized_man <= `BSV_ASSIGNMENT_DELAY 6'd0;
	output_man <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_operands <= `BSV_ASSIGNMENT_DELAY 80'd0;
	sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	sign_op2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stage <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (exp_op1$EN) exp_op1 <= `BSV_ASSIGNMENT_DELAY exp_op1$D_IN;
	if (exp_op2$EN) exp_op2 <= `BSV_ASSIGNMENT_DELAY exp_op2$D_IN;
	if (final_exp$EN) final_exp <= `BSV_ASSIGNMENT_DELAY final_exp$D_IN;
	if (final_man$EN) final_man <= `BSV_ASSIGNMENT_DELAY final_man$D_IN;
	if (final_output$EN)
	  final_output <= `BSV_ASSIGNMENT_DELAY final_output$D_IN;
	if (final_sign$EN)
	  final_sign <= `BSV_ASSIGNMENT_DELAY final_sign$D_IN;
	if (man_op1$EN) man_op1 <= `BSV_ASSIGNMENT_DELAY man_op1$D_IN;
	if (man_op2$EN) man_op2 <= `BSV_ASSIGNMENT_DELAY man_op2$D_IN;
	if (normalized_count$EN)
	  normalized_count <= `BSV_ASSIGNMENT_DELAY normalized_count$D_IN;
	if (normalized_man$EN)
	  normalized_man <= `BSV_ASSIGNMENT_DELAY normalized_man$D_IN;
	if (output_man$EN)
	  output_man <= `BSV_ASSIGNMENT_DELAY output_man$D_IN;
	if (rg_operands$EN)
	  rg_operands <= `BSV_ASSIGNMENT_DELAY rg_operands$D_IN;
	if (sign_op1$EN) sign_op1 <= `BSV_ASSIGNMENT_DELAY sign_op1$D_IN;
	if (sign_op2$EN) sign_op2 <= `BSV_ASSIGNMENT_DELAY sign_op2$D_IN;
	if (stage$EN) stage <= `BSV_ASSIGNMENT_DELAY stage$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    exp_op1 = 4'hA;
    exp_op2 = 4'hA;
    final_exp = 4'hA;
    final_man = 8'hAA;
    final_output = 8'hAA;
    final_sign = 1'h0;
    man_op1 = 3'h2;
    man_op2 = 3'h2;
    normalized_count = 4'hA;
    normalized_man = 6'h2A;
    output_man = 3'h2;
    rg_operands = 80'hAAAAAAAAAAAAAAAAAAAA;
    sign_op1 = 1'h0;
    sign_op2 = 1'h0;
    stage = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    $display("welcome to the project");
    $display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1)
	$display("DEBUGG ::: sign_op1 :", sign_op1, " sign_op2 :", sign_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1) $display("val of final sign : ", final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1) $display("val of stage: ", stage);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2) $display("stage2");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("DEBUGG of prev stage ::: sign_op1 :",
		 sign_op1,
		 " sign_op2 :",
		 sign_op2,
		 " final_sign :",
		 final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("DEBUGG ::: exp_op1 :", exp_op1, " exp_op2 :", exp_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("val of final exp : ",
		 final_exp,
		 "val of bias : ",
		 $signed(rg_operands[31:0]),
		 rg_operands[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3) $display("stage3");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("DEBUGG of prev stage ::: exp_op1 :",
		 exp_op1,
		 " exp_op2 :",
		 exp_op2,
		 " final_exp",
		 final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("DEBUGG ::: man_op1 : ", man_op1, " man_op2 : ", man_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3) $display("final_man : %b", final_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4) $display("stage4");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("DEBUGG of prev stage ::: man_op1 : ",
		 man_op1,
		 " man_op2 : ",
		 man_op2,
		 "output man : ",
		 output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("val of final output : ", final_output);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_output) $display("stage5");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_output)
	$display("INTER VALUES sign : ",
		 final_sign,
		 " exp : ",
		 final_exp,
		 " mantissa : ",
		 output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_display_output)
	$display("displaying the output ::: sign",
		 final_output[7],
		 " exp : ",
		 final_output[6:3],
		 " man : ",
		 final_output[2:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_send) $display("Inside the method SEND");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_send)
	$display("val at operand1 is : ",
		 rg_operands[79:72],
		 " operand2 : ",
		 rg_operands[71:64],
		 " r mode : ",
		 $signed(rg_operands[63:32]),
		 " exp_bias",
		 $signed(rg_operands[31:0]));
  end
  // synopsys translate_on
endmodule  // cfloat8_mul

