//
// Generated by Bluespec Compiler, version 2022.01-10-g3a4741b2 (build 3a4741b2)
//
// On Wed Dec  6 22:27:45 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTestbench(CLK,
		   RST_N);
  input  CLK;
  input  RST_N;

  // register count
  reg [31 : 0] count;
  wire [31 : 0] count$D_IN;
  wire count$EN;

  // register testmodule_exp_op1
  reg [3 : 0] testmodule_exp_op1;
  wire [3 : 0] testmodule_exp_op1$D_IN;
  wire testmodule_exp_op1$EN;

  // register testmodule_exp_op2
  reg [3 : 0] testmodule_exp_op2;
  wire [3 : 0] testmodule_exp_op2$D_IN;
  wire testmodule_exp_op2$EN;

  // register testmodule_final_exp
  reg [3 : 0] testmodule_final_exp;
  wire [3 : 0] testmodule_final_exp$D_IN;
  wire testmodule_final_exp$EN;

  // register testmodule_final_man
  reg [5 : 0] testmodule_final_man;
  wire [5 : 0] testmodule_final_man$D_IN;
  wire testmodule_final_man$EN;

  // register testmodule_final_output
  reg [7 : 0] testmodule_final_output;
  wire [7 : 0] testmodule_final_output$D_IN;
  wire testmodule_final_output$EN;

  // register testmodule_final_sign
  reg testmodule_final_sign;
  wire testmodule_final_sign$D_IN, testmodule_final_sign$EN;

  // register testmodule_man_op1
  reg [2 : 0] testmodule_man_op1;
  wire [2 : 0] testmodule_man_op1$D_IN;
  wire testmodule_man_op1$EN;

  // register testmodule_man_op2
  reg [2 : 0] testmodule_man_op2;
  wire [2 : 0] testmodule_man_op2$D_IN;
  wire testmodule_man_op2$EN;

  // register testmodule_output_man
  reg [2 : 0] testmodule_output_man;
  wire [2 : 0] testmodule_output_man$D_IN;
  wire testmodule_output_man$EN;

  // register testmodule_rg_operands
  reg [79 : 0] testmodule_rg_operands;
  wire [79 : 0] testmodule_rg_operands$D_IN;
  wire testmodule_rg_operands$EN;

  // register testmodule_sign_op1
  reg testmodule_sign_op1;
  wire testmodule_sign_op1$D_IN, testmodule_sign_op1$EN;

  // register testmodule_sign_op2
  reg testmodule_sign_op2;
  wire testmodule_sign_op2$D_IN, testmodule_sign_op2$EN;

  // register testmodule_stage
  reg [2 : 0] testmodule_stage;
  reg [2 : 0] testmodule_stage$D_IN;
  wire testmodule_stage$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_giveInp,
       CAN_FIRE_RL_greet,
       CAN_FIRE_RL_testmodule_display_output,
       CAN_FIRE_RL_testmodule_stage1,
       CAN_FIRE_RL_testmodule_stage2,
       CAN_FIRE_RL_testmodule_stage3,
       CAN_FIRE_RL_testmodule_stage4,
       CAN_FIRE_RL_testmodule_trial,
       WILL_FIRE_RL_giveInp,
       WILL_FIRE_RL_greet,
       WILL_FIRE_RL_testmodule_display_output,
       WILL_FIRE_RL_testmodule_stage1,
       WILL_FIRE_RL_testmodule_stage2,
       WILL_FIRE_RL_testmodule_stage3,
       WILL_FIRE_RL_testmodule_stage4,
       WILL_FIRE_RL_testmodule_trial;

  // inputs to muxes for submodule ports
  wire [2 : 0] MUX_testmodule_stage$write_1__VAL_2;

  // remaining internal signals
  wire [11 : 0] _0_CONCAT_testmodule_man_op1_3_4_MUL_0_CONCAT_t_ETC___d27;
  wire [2 : 0] x__h1457;

  // rule RL_testmodule_trial
  assign CAN_FIRE_RL_testmodule_trial = 1'd1 ;
  assign WILL_FIRE_RL_testmodule_trial = 1'd1 ;

  // rule RL_testmodule_stage1
  assign CAN_FIRE_RL_testmodule_stage1 = testmodule_stage == 3'd1 ;
  assign WILL_FIRE_RL_testmodule_stage1 = CAN_FIRE_RL_testmodule_stage1 ;

  // rule RL_testmodule_stage2
  assign CAN_FIRE_RL_testmodule_stage2 = testmodule_stage == 3'd2 ;
  assign WILL_FIRE_RL_testmodule_stage2 = CAN_FIRE_RL_testmodule_stage2 ;

  // rule RL_testmodule_stage3
  assign CAN_FIRE_RL_testmodule_stage3 = testmodule_stage == 3'd3 ;
  assign WILL_FIRE_RL_testmodule_stage3 = CAN_FIRE_RL_testmodule_stage3 ;

  // rule RL_testmodule_stage4
  assign CAN_FIRE_RL_testmodule_stage4 = testmodule_stage == 3'd4 ;
  assign WILL_FIRE_RL_testmodule_stage4 = CAN_FIRE_RL_testmodule_stage4 ;

  // rule RL_testmodule_display_output
  assign CAN_FIRE_RL_testmodule_display_output = testmodule_stage == 3'd5 ;
  assign WILL_FIRE_RL_testmodule_display_output =
	     CAN_FIRE_RL_testmodule_display_output ;

  // rule RL_giveInp
  assign CAN_FIRE_RL_giveInp = (count ^ 32'h80000000) < 32'h80000002 ;
  assign WILL_FIRE_RL_giveInp = CAN_FIRE_RL_giveInp ;

  // rule RL_greet
  assign CAN_FIRE_RL_greet = 1'd1 ;
  assign WILL_FIRE_RL_greet = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_testmodule_stage$write_1__VAL_2 = testmodule_stage + 3'd1 ;

  // register count
  assign count$D_IN = count + 32'd1 ;
  assign count$EN = 1'd1 ;

  // register testmodule_exp_op1
  assign testmodule_exp_op1$D_IN = testmodule_rg_operands[78:75] ;
  assign testmodule_exp_op1$EN = CAN_FIRE_RL_testmodule_stage2 ;

  // register testmodule_exp_op2
  assign testmodule_exp_op2$D_IN = testmodule_rg_operands[70:67] ;
  assign testmodule_exp_op2$EN = CAN_FIRE_RL_testmodule_stage2 ;

  // register testmodule_final_exp
  assign testmodule_final_exp$D_IN = testmodule_exp_op1 + testmodule_exp_op2 ;
  assign testmodule_final_exp$EN = CAN_FIRE_RL_testmodule_stage2 ;

  // register testmodule_final_man
  assign testmodule_final_man$D_IN =
	     _0_CONCAT_testmodule_man_op1_3_4_MUL_0_CONCAT_t_ETC___d27[5:0] ;
  assign testmodule_final_man$EN = CAN_FIRE_RL_testmodule_stage3 ;

  // register testmodule_final_output
  assign testmodule_final_output$D_IN =
	     { testmodule_final_sign,
	       testmodule_final_exp,
	       testmodule_output_man } ;
  assign testmodule_final_output$EN = CAN_FIRE_RL_testmodule_stage4 ;

  // register testmodule_final_sign
  assign testmodule_final_sign$D_IN =
	     testmodule_sign_op1 ^ testmodule_sign_op2 ;
  assign testmodule_final_sign$EN = CAN_FIRE_RL_testmodule_stage1 ;

  // register testmodule_man_op1
  assign testmodule_man_op1$D_IN = testmodule_rg_operands[74:72] ;
  assign testmodule_man_op1$EN = CAN_FIRE_RL_testmodule_stage3 ;

  // register testmodule_man_op2
  assign testmodule_man_op2$D_IN = testmodule_rg_operands[66:64] ;
  assign testmodule_man_op2$EN = CAN_FIRE_RL_testmodule_stage3 ;

  // register testmodule_output_man
  assign testmodule_output_man$D_IN =
	     testmodule_final_man[2] ? x__h1457 : testmodule_final_man[5:3] ;
  assign testmodule_output_man$EN = CAN_FIRE_RL_testmodule_stage3 ;

  // register testmodule_rg_operands
  assign testmodule_rg_operands$D_IN = 80'h13C40000000100000004 ;
  assign testmodule_rg_operands$EN = CAN_FIRE_RL_giveInp ;

  // register testmodule_sign_op1
  assign testmodule_sign_op1$D_IN = testmodule_rg_operands[79] ;
  assign testmodule_sign_op1$EN = CAN_FIRE_RL_testmodule_stage1 ;

  // register testmodule_sign_op2
  assign testmodule_sign_op2$D_IN = testmodule_rg_operands[71] ;
  assign testmodule_sign_op2$EN = CAN_FIRE_RL_testmodule_stage1 ;

  // register testmodule_stage
  always@(WILL_FIRE_RL_giveInp or
	  WILL_FIRE_RL_testmodule_stage4 or
	  MUX_testmodule_stage$write_1__VAL_2 or
	  WILL_FIRE_RL_testmodule_stage3 or
	  WILL_FIRE_RL_testmodule_stage2 or WILL_FIRE_RL_testmodule_stage1)
  case (1'b1)
    WILL_FIRE_RL_giveInp: testmodule_stage$D_IN = 3'd1;
    WILL_FIRE_RL_testmodule_stage4:
	testmodule_stage$D_IN = MUX_testmodule_stage$write_1__VAL_2;
    WILL_FIRE_RL_testmodule_stage3:
	testmodule_stage$D_IN = MUX_testmodule_stage$write_1__VAL_2;
    WILL_FIRE_RL_testmodule_stage2:
	testmodule_stage$D_IN = MUX_testmodule_stage$write_1__VAL_2;
    WILL_FIRE_RL_testmodule_stage1:
	testmodule_stage$D_IN = MUX_testmodule_stage$write_1__VAL_2;
    default: testmodule_stage$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign testmodule_stage$EN =
	     WILL_FIRE_RL_testmodule_stage4 ||
	     WILL_FIRE_RL_testmodule_stage3 ||
	     WILL_FIRE_RL_testmodule_stage2 ||
	     WILL_FIRE_RL_testmodule_stage1 ||
	     WILL_FIRE_RL_giveInp ;

  // remaining internal signals
  assign _0_CONCAT_testmodule_man_op1_3_4_MUL_0_CONCAT_t_ETC___d27 =
	     { 3'd0, testmodule_man_op1 } * { 3'd0, testmodule_man_op2 } ;
  assign x__h1457 = testmodule_final_man[5:3] + 3'b001 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	testmodule_exp_op1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	testmodule_exp_op2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	testmodule_final_exp <= `BSV_ASSIGNMENT_DELAY 4'd0;
	testmodule_final_man <= `BSV_ASSIGNMENT_DELAY 6'd0;
	testmodule_final_output <= `BSV_ASSIGNMENT_DELAY 8'd0;
	testmodule_final_sign <= `BSV_ASSIGNMENT_DELAY 1'd0;
	testmodule_man_op1 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	testmodule_man_op2 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	testmodule_output_man <= `BSV_ASSIGNMENT_DELAY 3'd0;
	testmodule_rg_operands <= `BSV_ASSIGNMENT_DELAY 80'd0;
	testmodule_sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	testmodule_sign_op2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	testmodule_stage <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (testmodule_exp_op1$EN)
	  testmodule_exp_op1 <= `BSV_ASSIGNMENT_DELAY testmodule_exp_op1$D_IN;
	if (testmodule_exp_op2$EN)
	  testmodule_exp_op2 <= `BSV_ASSIGNMENT_DELAY testmodule_exp_op2$D_IN;
	if (testmodule_final_exp$EN)
	  testmodule_final_exp <= `BSV_ASSIGNMENT_DELAY
	      testmodule_final_exp$D_IN;
	if (testmodule_final_man$EN)
	  testmodule_final_man <= `BSV_ASSIGNMENT_DELAY
	      testmodule_final_man$D_IN;
	if (testmodule_final_output$EN)
	  testmodule_final_output <= `BSV_ASSIGNMENT_DELAY
	      testmodule_final_output$D_IN;
	if (testmodule_final_sign$EN)
	  testmodule_final_sign <= `BSV_ASSIGNMENT_DELAY
	      testmodule_final_sign$D_IN;
	if (testmodule_man_op1$EN)
	  testmodule_man_op1 <= `BSV_ASSIGNMENT_DELAY testmodule_man_op1$D_IN;
	if (testmodule_man_op2$EN)
	  testmodule_man_op2 <= `BSV_ASSIGNMENT_DELAY testmodule_man_op2$D_IN;
	if (testmodule_output_man$EN)
	  testmodule_output_man <= `BSV_ASSIGNMENT_DELAY
	      testmodule_output_man$D_IN;
	if (testmodule_rg_operands$EN)
	  testmodule_rg_operands <= `BSV_ASSIGNMENT_DELAY
	      testmodule_rg_operands$D_IN;
	if (testmodule_sign_op1$EN)
	  testmodule_sign_op1 <= `BSV_ASSIGNMENT_DELAY
	      testmodule_sign_op1$D_IN;
	if (testmodule_sign_op2$EN)
	  testmodule_sign_op2 <= `BSV_ASSIGNMENT_DELAY
	      testmodule_sign_op2$D_IN;
	if (testmodule_stage$EN)
	  testmodule_stage <= `BSV_ASSIGNMENT_DELAY testmodule_stage$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 32'hAAAAAAAA;
    testmodule_exp_op1 = 4'hA;
    testmodule_exp_op2 = 4'hA;
    testmodule_final_exp = 4'hA;
    testmodule_final_man = 6'h2A;
    testmodule_final_output = 8'hAA;
    testmodule_final_sign = 1'h0;
    testmodule_man_op1 = 3'h2;
    testmodule_man_op2 = 3'h2;
    testmodule_output_man = 3'h2;
    testmodule_rg_operands = 80'hAAAAAAAAAAAAAAAAAAAA;
    testmodule_sign_op1 = 1'h0;
    testmodule_sign_op2 = 1'h0;
    testmodule_stage = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    $display("welcome to the project");
    $display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage1)
	$display("DEBUGG ::: sign_op1 :",
		 testmodule_sign_op1,
		 " sign_op2 :",
		 testmodule_sign_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage1)
	$display("val of final sign : ", testmodule_final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage1)
	$display("val of stage: ", testmodule_stage);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage1)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage2) $display("stage2");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage2)
	$display("DEBUGG of prev stage ::: sign_op1 :",
		 testmodule_sign_op1,
		 " sign_op2 :",
		 testmodule_sign_op2,
		 " final_sign :",
		 testmodule_final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage2)
	$display("DEBUGG ::: exp_op1 :",
		 testmodule_exp_op1,
		 " exp_op2 :",
		 testmodule_exp_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage2)
	$display("val of final exp : ",
		 testmodule_final_exp,
		 "val of bias : ",
		 $signed(testmodule_rg_operands[31:0]),
		 testmodule_rg_operands[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage2)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3) $display("stage3");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3)
	$display("DEBUGG of prev stage ::: exp_op1 :",
		 testmodule_exp_op1,
		 " exp_op2 :",
		 testmodule_exp_op2,
		 " final_exp",
		 testmodule_final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3)
	$display("DEBUGG ::: man_op1 : ",
		 testmodule_man_op1,
		 " man_op2 : ",
		 testmodule_man_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3)
	$display("final_man : %b", testmodule_final_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3 && testmodule_final_man[2])
	$display("val aft rounding : %b", testmodule_output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3 && !testmodule_final_man[2])
	$display("val aft rounding : %b", testmodule_output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage3)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage4) $display("stage4");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage4)
	$display("DEBUGG of prev stage ::: man_op1 : ",
		 testmodule_man_op1,
		 " man_op2 : ",
		 testmodule_man_op2,
		 "output man : ",
		 testmodule_output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage4)
	$display("val of final output : ", testmodule_final_output);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_stage4)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_display_output) $display("stage5");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_display_output)
	$display("INTER VALUES sign : ",
		 testmodule_final_sign,
		 " exp : ",
		 testmodule_final_exp,
		 " mantissa : ",
		 testmodule_output_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_testmodule_display_output)
	$display("displaying the output ::: sign",
		 testmodule_final_output[7],
		 " exp : ",
		 testmodule_final_output[6:3],
		 " man : ",
		 testmodule_final_output[2:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_giveInp) $display("Inside the method SEND");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_giveInp)
	$display("val at operand1 is : ",
		 testmodule_rg_operands[79:72],
		 " operand2 : ",
		 testmodule_rg_operands[71:64],
		 " r mode : ",
		 $signed(testmodule_rg_operands[63:32]),
		 " exp_bias",
		 $signed(testmodule_rg_operands[31:0]));
    if (RST_N != `BSV_RESET_VALUE)
      if ((count ^ 32'h80000000) > 32'h80000006) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE) $display("hi dina");
  end
  // synopsys translate_on
endmodule  // mkTestbench

