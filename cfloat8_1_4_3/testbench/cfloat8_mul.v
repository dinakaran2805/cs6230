//
// Generated by Bluespec Compiler, version 2022.01-10-g3a4741b2 (build 3a4741b2)
//
// On Sun Dec 10 11:01:29 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_send                       O     1 const
// receive                        O     8 reg
// RDY_receive                    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// send_data_input                I    21 reg
// EN_send                        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module cfloat8_mul(CLK,
		   RST_N,

		   send_data_input,
		   EN_send,
		   RDY_send,

		   receive,
		   RDY_receive);
  input  CLK;
  input  RST_N;

  // action method send
  input  [20 : 0] send_data_input;
  input  EN_send;
  output RDY_send;

  // value method receive
  output [7 : 0] receive;
  output RDY_receive;

  // signals for module outputs
  wire [7 : 0] receive;
  wire RDY_receive, RDY_send;

  // register exp_op1
  reg [3 : 0] exp_op1;
  wire [3 : 0] exp_op1$D_IN;
  wire exp_op1$EN;

  // register exp_op2
  reg [3 : 0] exp_op2;
  wire [3 : 0] exp_op2$D_IN;
  wire exp_op2$EN;

  // register final_bias
  reg [3 : 0] final_bias;
  wire [3 : 0] final_bias$D_IN;
  wire final_bias$EN;

  // register final_exp
  reg [3 : 0] final_exp;
  wire [3 : 0] final_exp$D_IN;
  wire final_exp$EN;

  // register final_man
  reg [7 : 0] final_man;
  wire [7 : 0] final_man$D_IN;
  wire final_man$EN;

  // register final_output
  reg [7 : 0] final_output;
  wire [7 : 0] final_output$D_IN;
  wire final_output$EN;

  // register final_sign
  reg final_sign;
  wire final_sign$D_IN, final_sign$EN;

  // register man_op1
  reg [2 : 0] man_op1;
  wire [2 : 0] man_op1$D_IN;
  wire man_op1$EN;

  // register man_op2
  reg [2 : 0] man_op2;
  wire [2 : 0] man_op2$D_IN;
  wire man_op2$EN;

  // register normalized_count
  reg [3 : 0] normalized_count;
  wire [3 : 0] normalized_count$D_IN;
  wire normalized_count$EN;

  // register normalized_man
  reg [5 : 0] normalized_man;
  reg [5 : 0] normalized_man$D_IN;
  wire normalized_man$EN;

  // register output_man
  reg [2 : 0] output_man;
  wire [2 : 0] output_man$D_IN;
  wire output_man$EN;

  // register rg_operands
  reg [20 : 0] rg_operands;
  wire [20 : 0] rg_operands$D_IN;
  wire rg_operands$EN;

  // register rounded_man
  reg [2 : 0] rounded_man;
  wire [2 : 0] rounded_man$D_IN;
  wire rounded_man$EN;

  // register sign_op1
  reg sign_op1;
  wire sign_op1$D_IN, sign_op1$EN;

  // register sign_op2
  reg sign_op2;
  wire sign_op2$D_IN, sign_op2$EN;

  // register stage
  reg [2 : 0] stage;
  reg [2 : 0] stage$D_IN;
  wire stage$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_stage1,
       CAN_FIRE_RL_stage2,
       CAN_FIRE_RL_stage3,
       CAN_FIRE_RL_stage4,
       CAN_FIRE_RL_stage5,
       CAN_FIRE_RL_trial,
       CAN_FIRE_send,
       WILL_FIRE_RL_stage1,
       WILL_FIRE_RL_stage2,
       WILL_FIRE_RL_stage3,
       WILL_FIRE_RL_stage4,
       WILL_FIRE_RL_stage5,
       WILL_FIRE_RL_trial,
       WILL_FIRE_send;

  // inputs to muxes for submodule ports
  reg [3 : 0] MUX_final_exp$write_1__VAL_1;
  wire [3 : 0] MUX_final_exp$write_1__VAL_2;
  wire [2 : 0] MUX_stage$write_1__VAL_2;
  wire MUX_final_exp$write_1__SEL_1;

  // remaining internal signals
  wire [7 : 0] NOT_exp_op1_5_EQ_0_2_3_CONCAT_man_op1_4_5_MUL__ETC___d30;
  wire [5 : 0] IF_0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_ETC___d60,
	       x__h1900,
	       x__h3146,
	       x__h3260;
  wire [3 : 0] count_temp__h2059,
	       inter_mantissa1__h1426,
	       inter_mantissa2__h1427,
	       x__h1971,
	       x__h3220;
  wire [2 : 0] IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_final_ma_ETC___d55,
	       rounded_value__h3724;
  wire _0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_ETC___d57,
       hidden_bit_op1__h1358,
       hidden_bit_op2__h1359;

  // action method send
  assign RDY_send = 1'd1 ;
  assign CAN_FIRE_send = 1'd1 ;
  assign WILL_FIRE_send = EN_send ;

  // value method receive
  assign receive = final_output ;
  assign RDY_receive = 1'd1 ;

  // rule RL_trial
  assign CAN_FIRE_RL_trial = 1'd1 ;
  assign WILL_FIRE_RL_trial = 1'd1 ;

  // rule RL_stage1
  assign CAN_FIRE_RL_stage1 = stage == 3'd1 ;
  assign WILL_FIRE_RL_stage1 = CAN_FIRE_RL_stage1 ;

  // rule RL_stage2
  assign CAN_FIRE_RL_stage2 = stage == 3'd2 ;
  assign WILL_FIRE_RL_stage2 = CAN_FIRE_RL_stage2 ;

  // rule RL_stage3
  assign CAN_FIRE_RL_stage3 = stage == 3'd3 ;
  assign WILL_FIRE_RL_stage3 = CAN_FIRE_RL_stage3 ;

  // rule RL_stage4
  assign CAN_FIRE_RL_stage4 = stage == 3'd4 ;
  assign WILL_FIRE_RL_stage4 = CAN_FIRE_RL_stage4 ;

  // rule RL_stage5
  assign CAN_FIRE_RL_stage5 = stage == 3'd5 ;
  assign WILL_FIRE_RL_stage5 = CAN_FIRE_RL_stage5 ;

  // inputs to muxes for submodule ports
  assign MUX_final_exp$write_1__SEL_1 =
	     WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 ;
  always@(final_man or
	  _0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_ETC___d57 or
	  x__h3220 or x__h1971)
  begin
    case (final_man[7:6])
      2'b10, 2'b11: MUX_final_exp$write_1__VAL_1 = x__h1971;
      default: MUX_final_exp$write_1__VAL_1 =
		   _0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_ETC___d57 ?
		     x__h3220 :
		     4'd0;
    endcase
  end
  assign MUX_final_exp$write_1__VAL_2 = exp_op1 + exp_op2 ;
  assign MUX_stage$write_1__VAL_2 = stage + 3'd1 ;

  // register exp_op1
  assign exp_op1$D_IN = rg_operands[19:16] ;
  assign exp_op1$EN = CAN_FIRE_RL_stage2 ;

  // register exp_op2
  assign exp_op2$D_IN = rg_operands[11:8] ;
  assign exp_op2$EN = CAN_FIRE_RL_stage2 ;

  // register final_bias
  assign final_bias$D_IN = rg_operands[3:0] ;
  assign final_bias$EN = CAN_FIRE_RL_stage2 ;

  // register final_exp
  assign final_exp$D_IN =
	     MUX_final_exp$write_1__SEL_1 ?
	       MUX_final_exp$write_1__VAL_1 :
	       MUX_final_exp$write_1__VAL_2 ;
  assign final_exp$EN =
	     WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 ||
	     WILL_FIRE_RL_stage2 ;

  // register final_man
  assign final_man$D_IN =
	     { 4'd0,
	       NOT_exp_op1_5_EQ_0_2_3_CONCAT_man_op1_4_5_MUL__ETC___d30[3:0] } ;
  assign final_man$EN = CAN_FIRE_RL_stage3 ;

  // register final_output
  assign final_output$D_IN = { final_sign, final_exp, rounded_man } ;
  assign final_output$EN = CAN_FIRE_RL_stage5 ;

  // register final_sign
  assign final_sign$D_IN = sign_op1 ^ sign_op2 ;
  assign final_sign$EN = CAN_FIRE_RL_stage1 ;

  // register man_op1
  assign man_op1$D_IN = rg_operands[15:13] ;
  assign man_op1$EN = CAN_FIRE_RL_stage3 ;

  // register man_op2
  assign man_op2$D_IN = rg_operands[7:5] ;
  assign man_op2$EN = CAN_FIRE_RL_stage3 ;

  // register normalized_count
  assign normalized_count$D_IN = 4'h0 ;
  assign normalized_count$EN = 1'b0 ;

  // register normalized_man
  always@(final_man or
	  IF_0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_ETC___d60 or
	  x__h1900)
  begin
    case (final_man[7:6])
      2'd0:
	  normalized_man$D_IN =
	      IF_0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_ETC___d60;
      2'b01: normalized_man$D_IN = final_man[5:0];
      2'b10, 2'b11: normalized_man$D_IN = x__h1900;
    endcase
  end
  assign normalized_man$EN = CAN_FIRE_RL_stage4 ;

  // register output_man
  assign output_man$D_IN = 3'h0 ;
  assign output_man$EN = 1'b0 ;

  // register rg_operands
  assign rg_operands$D_IN = send_data_input ;
  assign rg_operands$EN = EN_send ;

  // register rounded_man
  assign rounded_man$D_IN =
	     normalized_man[2] ? rounded_value__h3724 : normalized_man[5:3] ;
  assign rounded_man$EN = WILL_FIRE_RL_stage5 && rg_operands[4] ;

  // register sign_op1
  assign sign_op1$D_IN = rg_operands[20] ;
  assign sign_op1$EN = CAN_FIRE_RL_stage1 ;

  // register sign_op2
  assign sign_op2$D_IN = rg_operands[12] ;
  assign sign_op2$EN = CAN_FIRE_RL_stage1 ;

  // register stage
  always@(EN_send or
	  WILL_FIRE_RL_stage4 or
	  MUX_stage$write_1__VAL_2 or
	  WILL_FIRE_RL_stage3 or WILL_FIRE_RL_stage2 or WILL_FIRE_RL_stage1)
  case (1'b1)
    EN_send: stage$D_IN = 3'd1;
    WILL_FIRE_RL_stage4: stage$D_IN = MUX_stage$write_1__VAL_2;
    WILL_FIRE_RL_stage3: stage$D_IN = MUX_stage$write_1__VAL_2;
    WILL_FIRE_RL_stage2: stage$D_IN = MUX_stage$write_1__VAL_2;
    WILL_FIRE_RL_stage1: stage$D_IN = MUX_stage$write_1__VAL_2;
    default: stage$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign stage$EN =
	     WILL_FIRE_RL_stage4 || WILL_FIRE_RL_stage3 ||
	     WILL_FIRE_RL_stage2 ||
	     WILL_FIRE_RL_stage1 ||
	     EN_send ;

  // remaining internal signals
  assign IF_0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_ETC___d60 =
	     _0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_ETC___d57 ?
	       x__h3146 :
	       x__h3260 ;
  assign IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_final_ma_ETC___d55 =
	     (final_man[5] ?
		3'd0 :
		(final_man[4] ?
		   3'd1 :
		   (final_man[3] ?
		      3'd2 :
		      (final_man[2] ?
			 3'd3 :
			 (final_man[1] ?
			    3'd4 :
			    (final_man[0] ? 3'd5 : 3'd6)))))) +
	     3'd1 ;
  assign NOT_exp_op1_5_EQ_0_2_3_CONCAT_man_op1_4_5_MUL__ETC___d30 =
	     inter_mantissa1__h1426 * inter_mantissa2__h1427 ;
  assign _0_CONCAT_IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_ETC___d57 =
	     count_temp__h2059 < final_exp ;
  assign count_temp__h2059 =
	     { 1'd0,
	       IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_final_ma_ETC___d55 } ;
  assign hidden_bit_op1__h1358 = exp_op1 != 4'd0 ;
  assign hidden_bit_op2__h1359 = exp_op2 != 4'd0 ;
  assign inter_mantissa1__h1426 = { hidden_bit_op1__h1358, man_op1 } ;
  assign inter_mantissa2__h1427 = { hidden_bit_op2__h1359, man_op2 } ;
  assign rounded_value__h3724 = normalized_man[5:3] + 3'b001 ;
  assign x__h1900 = { 1'd0, final_man[5:1] } ;
  assign x__h1971 = final_exp + 4'd1 ;
  assign x__h3146 = final_man[5:0] << count_temp__h2059 ;
  assign x__h3220 = final_exp - count_temp__h2059 ;
  assign x__h3260 = final_man[5:0] << final_exp ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        exp_op1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	exp_op2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	final_bias <= `BSV_ASSIGNMENT_DELAY 4'd0;
	final_exp <= `BSV_ASSIGNMENT_DELAY 4'd0;
	final_man <= `BSV_ASSIGNMENT_DELAY 8'd0;
	final_output <= `BSV_ASSIGNMENT_DELAY 8'd0;
	final_sign <= `BSV_ASSIGNMENT_DELAY 1'd0;
	man_op1 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	man_op2 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	normalized_count <= `BSV_ASSIGNMENT_DELAY 4'd0;
	normalized_man <= `BSV_ASSIGNMENT_DELAY 6'd0;
	output_man <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_operands <= `BSV_ASSIGNMENT_DELAY 21'd0;
	rounded_man <= `BSV_ASSIGNMENT_DELAY 3'd0;
	sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	sign_op2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stage <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (exp_op1$EN) exp_op1 <= `BSV_ASSIGNMENT_DELAY exp_op1$D_IN;
	if (exp_op2$EN) exp_op2 <= `BSV_ASSIGNMENT_DELAY exp_op2$D_IN;
	if (final_bias$EN)
	  final_bias <= `BSV_ASSIGNMENT_DELAY final_bias$D_IN;
	if (final_exp$EN) final_exp <= `BSV_ASSIGNMENT_DELAY final_exp$D_IN;
	if (final_man$EN) final_man <= `BSV_ASSIGNMENT_DELAY final_man$D_IN;
	if (final_output$EN)
	  final_output <= `BSV_ASSIGNMENT_DELAY final_output$D_IN;
	if (final_sign$EN)
	  final_sign <= `BSV_ASSIGNMENT_DELAY final_sign$D_IN;
	if (man_op1$EN) man_op1 <= `BSV_ASSIGNMENT_DELAY man_op1$D_IN;
	if (man_op2$EN) man_op2 <= `BSV_ASSIGNMENT_DELAY man_op2$D_IN;
	if (normalized_count$EN)
	  normalized_count <= `BSV_ASSIGNMENT_DELAY normalized_count$D_IN;
	if (normalized_man$EN)
	  normalized_man <= `BSV_ASSIGNMENT_DELAY normalized_man$D_IN;
	if (output_man$EN)
	  output_man <= `BSV_ASSIGNMENT_DELAY output_man$D_IN;
	if (rg_operands$EN)
	  rg_operands <= `BSV_ASSIGNMENT_DELAY rg_operands$D_IN;
	if (rounded_man$EN)
	  rounded_man <= `BSV_ASSIGNMENT_DELAY rounded_man$D_IN;
	if (sign_op1$EN) sign_op1 <= `BSV_ASSIGNMENT_DELAY sign_op1$D_IN;
	if (sign_op2$EN) sign_op2 <= `BSV_ASSIGNMENT_DELAY sign_op2$D_IN;
	if (stage$EN) stage <= `BSV_ASSIGNMENT_DELAY stage$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    exp_op1 = 4'hA;
    exp_op2 = 4'hA;
    final_bias = 4'hA;
    final_exp = 4'hA;
    final_man = 8'hAA;
    final_output = 8'hAA;
    final_sign = 1'h0;
    man_op1 = 3'h2;
    man_op2 = 3'h2;
    normalized_count = 4'hA;
    normalized_man = 6'h2A;
    output_man = 3'h2;
    rg_operands = 21'h0AAAAA;
    rounded_man = 3'h2;
    sign_op1 = 1'h0;
    sign_op2 = 1'h0;
    stage = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    $display("welcome to the project");
    $display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1)
	$display("DEBUGG ::: sign_op1 :", sign_op1, " sign_op2 :", sign_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1) $display("val of final sign : ", final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1) $display("val of stage: ", stage);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage1)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2) $display("stage2");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("DEBUGG of prev stage ::: sign_op1 :",
		 sign_op1,
		 " sign_op2 :",
		 sign_op2,
		 " final_sign :",
		 final_sign);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("DEBUGG ::: exp_op1 :", exp_op1, " exp_op2 :", exp_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("val of final exp : ",
		 final_exp,
		 "val of bias : ",
		 rg_operands[3:0],
		 rg_operands[3:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("DINA DEBUGGG : val of final_exp : %b", final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage2)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3) $display("stage3");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("DEBUGG of prev stage ::: exp_op1 :",
		 exp_op1,
		 " exp_op2 :",
		 exp_op2,
		 " final_exp",
		 final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("DEBUGG ::: man_op1 : ", man_op1, " man_op2 : ", man_op2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3) $display("final_man : %b", final_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage3)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4) $display("val of final man : %b ", final_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 &&
	  (final_man[7:6] == 2'b10 || final_man[7:6] == 2'b11))
	$display("the value of the hidden product is 10 or 11 . The exact value is : %b",
		 final_man[7:6]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 &&
	  (final_man[7:6] == 2'b10 || final_man[7:6] == 2'b11))
	$display("before shifting : %b",
		 final_man[5:0],
		 "after shifting : %b ",
		 normalized_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 &&
	  final_man[7:6] != 2'b10 &&
	  final_man[7:6] != 2'b11)
	$display("latest DEBUGG : count_temp  : %b",
		 count_temp__h2059,
		 "final_exp : %b ",
		 final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 &&
	  final_man[7:6] != 2'b10 &&
	  final_man[7:6] != 2'b11)
	$display("DEBUGG MSB count zeros : %b ",
		 $unsigned(IF_final_man_3_BIT_5_3_THEN_0_ELSE_IF_final_ma_ETC___d55),
		 "final exp : %b",
		 final_exp);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4 && final_man[7:6] != 2'b01 &&
	  final_man[7:6] != 2'b10 &&
	  final_man[7:6] != 2'b11)
	$display("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("value of normalized man : %b", normalized_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4) $display("stage4");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("val of final output : ", final_output);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("DEBUGG of prev stage ::: man_op1 : ",
		 man_op1,
		 " man_op2 : ",
		 man_op2,
		 "output man : %b",
		 normalized_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage4)
	$display("***************************************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage5) $display("stage5");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage5)
	$display("value of rounded man : %b", rounded_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage5)
	$display("INTER VALUES sign : ",
		 final_sign,
		 " exp : ",
		 final_exp,
		 " mantissa : ",
		 rounded_man);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stage5)
	$display("displaying the output ::: sign",
		 final_output[7],
		 " exp : ",
		 final_output[6:3],
		 " man : ",
		 final_output[2:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_send) $display("Inside the method SEND");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_send)
	$display("val at operand1 is : ",
		 rg_operands[20:13],
		 " operand2 : ",
		 rg_operands[12:5],
		 " r mode : ",
		 rg_operands[4],
		 " exp_bias",
		 rg_operands[3:0]);
  end
  // synopsys translate_on
endmodule  // cfloat8_mul

